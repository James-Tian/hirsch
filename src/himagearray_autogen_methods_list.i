    {"HarmonicInterpolation", (PyCFunction)PyHirschImageArray_HarmonicInterpolation, METH_VARARGS, "HarmonicInterpolation(Region,Precision)\n\nPerform a harmonic interpolation on an image region." },
    {"MapImage", (PyCFunction)PyHirschImageArray_MapImage, METH_VARARGS, "MapImage(Map)\n\nApply a general transformation to an image." },
    {"VectorFieldLength", (PyCFunction)PyHirschImageArray_VectorFieldLength, METH_VARARGS, "VectorFieldLength(Mode)\n\nCompute the length of the vectors of a vector field." },
    {"SelectGrayvaluesFromChannels", (PyCFunction)PyHirschImageArray_SelectGrayvaluesFromChannels, METH_VARARGS, "SelectGrayvaluesFromChannels(IndexImage)\n\nSelection of gray values of a multi-channel image using an index image." },
    {"ConvertImageType", (PyCFunction)PyHirschImageArray_ConvertImageType, METH_VARARGS, "ConvertImageType(NewType)\n\nConvert the type of an image." },
    {"SobelAmp", (PyCFunction)PyHirschImageArray_SobelAmp, METH_VARARGS, "SobelAmp(FilterType,Size)\n\nDetect edges (amplitude) using the Sobel operator." },
    {"DetectEdgeSegments", (PyCFunction)PyHirschImageArray_DetectEdgeSegments, METH_VARARGS, "DetectEdgeSegments(SobelSize,MinAmplitude,MaxDistance,MinLength)\n\nDetect straight edge segments." },
    {"SfsModLr", (PyCFunction)PyHirschImageArray_SfsModLr, METH_VARARGS, "SfsModLr(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"GenCubeMapMosaic", (PyCFunction)PyHirschImageArray_GenCubeMapMosaic, METH_VARARGS, "GenCubeMapMosaic(CameraMatrices,RotationMatrices,CubeMapDimension,StackingOrder,Interpolation)\n\nCreate 6 cube map images of a spherical mosaic." },
    {"TrimmedMean", (PyCFunction)PyHirschImageArray_TrimmedMean, METH_VARARGS, "TrimmedMean(Mask,Number,Margin)\n\nSmooth an image with an arbitrary rank mask." },
    {"DepthFromFocus", (PyCFunction)PyHirschImageArray_DepthFromFocus, METH_VARARGS, "DepthFromFocus(Filter,Selection)\n\nExtract depth using mutiple focus levels." },
    {"BandpassImage", (PyCFunction)PyHirschImageArray_BandpassImage, METH_VARARGS, "BandpassImage(FilterType)\n\nEdge extraction using bandpass filters." },
    {"BestMatchRot", (PyCFunction)PyHirschImageArray_BestMatchRot, METH_VARARGS, "BestMatchRot(TemplateID,AngleStart,AngleExtend,MaxError,SubPixel)\n\nSearching the best matching of a template and an image with rotation." },
    {"ClassNdimNorm", (PyCFunction)PyHirschImageArray_ClassNdimNorm, METH_VARARGS, "ClassNdimNorm(Metric,SingleMultiple,Radius,Center)\n\nClassify pixels using hyper-spheres or hyper-cubes." },
    {"BinThreshold", (PyCFunction)PyHirschImageArray_BinThreshold, METH_NOARGS, "BinThreshold()\n\nSegment an image using an automatically determined\nthreshold." },
    {"TileChannels", (PyCFunction)PyHirschImageArray_TileChannels, METH_VARARGS, "TileChannels(NumColumns,TileOrder)\n\nTile multiple images into a large image." },
    {"MeanN", (PyCFunction)PyHirschImageArray_MeanN, METH_NOARGS, "MeanN()\n\nAverage gray values over several channels." },
    {"ClassDBID", (PyCFunction)PyHirschImageArray_ClassDBID, METH_NOARGS, "ClassDBID()\n\n" },
    {"EdgesColor", (PyCFunction)PyHirschImageArray_EdgesColor, METH_VARARGS, "EdgesColor(Filter,Alpha,NMS,Low,High)\n\nExtract color edges using Canny, Deriche, or Shen filters." },
    {"BinomialFilter", (PyCFunction)PyHirschImageArray_BinomialFilter, METH_VARARGS, "BinomialFilter(MaskWidth,MaskHeight)\n\nSmooth an image using the binomial filter." },
    {"HighpassImage", (PyCFunction)PyHirschImageArray_HighpassImage, METH_VARARGS, "HighpassImage(Width,Height)\n\nExtract high frequency components from an image." },
    {"PolarTransImageInv", (PyCFunction)PyHirschImageArray_PolarTransImageInv, METH_VARARGS, "PolarTransImageInv(Row,Column,AngleStart,AngleEnd,RadiusStart,RadiusEnd,Width,Height,Interpolation)\n\nTransform an image in polar coordinates back to cartesian coordinates" },
    {"GenBundleAdjustedMosaic", (PyCFunction)PyHirschImageArray_GenBundleAdjustedMosaic, METH_VARARGS, "GenBundleAdjustedMosaic(HomMatrices2D,StackingOrder,TransformRegion)\n\nCombine multiple images into a mosaic image." },
    {"GenSphericalMosaic", (PyCFunction)PyHirschImageArray_GenSphericalMosaic, METH_VARARGS, "GenSphericalMosaic(CameraMatrices,RotationMatrices,LatMin,LatMax,LongMin,LongMax,LatLongStep,StackingOrder,Interpolation)\n\nCreate a spherical mosaic image." },
    {"EliminateSp", (PyCFunction)PyHirschImageArray_EliminateSp, METH_VARARGS, "EliminateSp(MaskWidth,MaskHeight,MinThresh,MaxThresh)\n\nReplace values outside of thresholds with average value." },
    {"Compose4", (PyCFunction)PyHirschImageArray_Compose4, METH_VARARGS, "Compose4(Image2,Image3,Image4)\n\nConvert 4 images into a four-channel image." },
    {"Compose5", (PyCFunction)PyHirschImageArray_Compose5, METH_VARARGS, "Compose5(Image2,Image3,Image4,Image5)\n\nConvert 5 images into a five-channel image." },
    {"Compose6", (PyCFunction)PyHirschImageArray_Compose6, METH_VARARGS, "Compose6(Image2,Image3,Image4,Image5,Image6)\n\nConvert 6 images into a six-channel image." },
    {"Compose7", (PyCFunction)PyHirschImageArray_Compose7, METH_VARARGS, "Compose7(Image2,Image3,Image4,Image5,Image6,Image7)\n\nConvert 7 images into a seven-channel image." },
    {"LowlandsCenter", (PyCFunction)PyHirschImageArray_LowlandsCenter, METH_NOARGS, "LowlandsCenter()\n\nDetect the centers of all gray value lowlands." },
    {"Compose2", (PyCFunction)PyHirschImageArray_Compose2, METH_VARARGS, "Compose2(Image2)\n\nConvert two images into a two-channel image." },
    {"Compose3", (PyCFunction)PyHirschImageArray_Compose3, METH_VARARGS, "Compose3(Image2,Image3)\n\nConvert 3 images into a three-channel image." },
    {"TransToRgb", (PyCFunction)PyHirschImageArray_TransToRgb, METH_VARARGS, "TransToRgb(ImageInput2,ImageInput3,ColorSpace)\n\nTransform an image from an arbitrary color space to the RGB color space." },
    {"BestMatchRotMg", (PyCFunction)PyHirschImageArray_BestMatchRotMg, METH_VARARGS, "BestMatchRotMg(TemplateID,AngleStart,AngleExtend,MaxError,SubPixel,NumLevels)\n\nSearching the best matching of a template and a pyramid with rotation." },
    {"MinImage", (PyCFunction)PyHirschImageArray_MinImage, METH_VARARGS, "MinImage(Image2)\n\nCalculate the minimum of two images pixel by pixel." },
    {"TopographicSketch", (PyCFunction)PyHirschImageArray_TopographicSketch, METH_NOARGS, "TopographicSketch()\n\nCompute the topographic primal sketch of an image." },
    {"GrayErosionShape", (PyCFunction)PyHirschImageArray_GrayErosionShape, METH_VARARGS, "GrayErosionShape(MaskHeight,MaskWidth,MaskShape)\n\nDetermine the minimum gray value within a selected mask." },
    {"InvertImage", (PyCFunction)PyHirschImageArray_InvertImage, METH_NOARGS, "InvertImage()\n\nInvert an image." },
    {"GraySkeleton", (PyCFunction)PyHirschImageArray_GraySkeleton, METH_NOARGS, "GraySkeleton()\n\nThinning of gray value images." },
    {"CheckDifference", (PyCFunction)PyHirschImageArray_CheckDifference, METH_VARARGS, "CheckDifference(Pattern,Mode,DiffLowerBound,DiffUpperBound,GrayOffset,AddRow,AddCol)\n\nCompare two images pixel by pixel." },
    {"KirschAmp", (PyCFunction)PyHirschImageArray_KirschAmp, METH_NOARGS, "KirschAmp()\n\nDetect edges (amplitude) using the Kirsch operator." },
    {"PlateausCenter", (PyCFunction)PyHirschImageArray_PlateausCenter, METH_NOARGS, "PlateausCenter()\n\nDetect the centers of all gray value plateaus." },
    {"DiffOfGauss", (PyCFunction)PyHirschImageArray_DiffOfGauss, METH_VARARGS, "DiffOfGauss(Sigma,SigFactor)\n\nApproximate the LoG operator (Laplace of Gaussian)." },
    {"AddNoiseDistribution", (PyCFunction)PyHirschImageArray_AddNoiseDistribution, METH_VARARGS, "AddNoiseDistribution(Distribution)\n\nAdd noise to an image." },
    {"FillInterlace", (PyCFunction)PyHirschImageArray_FillInterlace, METH_VARARGS, "FillInterlace(Mode)\n\nInterpolate 2 video half images." },
    {"Roberts", (PyCFunction)PyHirschImageArray_Roberts, METH_VARARGS, "Roberts(FilterType)\n\nDetect edges using the Roberts filter." },
    {"BitAnd", (PyCFunction)PyHirschImageArray_BitAnd, METH_VARARGS, "BitAnd(Image2)\n\nBit-by-bit AND of all pixels of the input images." },
    {"MirrorImage", (PyCFunction)PyHirschImageArray_MirrorImage, METH_VARARGS, "MirrorImage(Mode)\n\nMirror an image." },
    {"ChangeFormat", (PyCFunction)PyHirschImageArray_ChangeFormat, METH_VARARGS, "ChangeFormat(Width,Height)\n\nChange image size." },
    {"AbsImage", (PyCFunction)PyHirschImageArray_AbsImage, METH_NOARGS, "AbsImage()\n\nCalculate the absolute value (modulus) of an image." },
    {"GrayErosionRect", (PyCFunction)PyHirschImageArray_GrayErosionRect, METH_VARARGS, "GrayErosionRect(MaskHeight,MaskWidth)\n\nDetermine the minimum gray value within a rectangle." },
    {"AdjustMosaicImages", (PyCFunction)PyHirschImageArray_AdjustMosaicImages, METH_VARARGS, "AdjustMosaicImages(From,To,ReferenceImage,HomMatrices2D,EstimationMethod,EstimateParameters,OECFModel)\n\nAutomatic color correction of panorama images." },
    {"InpaintingTexture", (PyCFunction)PyHirschImageArray_InpaintingTexture, METH_VARARGS, "InpaintingTexture(Region,MaskSize,SearchSize,Anisotropy,PostIteration,Smoothness)\n\nPerform an inpainting by texture propagation." },
    {"ComplexToReal", (PyCFunction)PyHirschImageArray_ComplexToReal, METH_NOARGS, "ComplexToReal()\n\nConvert a complex image into two real images." },
    {"BitLshift", (PyCFunction)PyHirschImageArray_BitLshift, METH_VARARGS, "BitLshift(Shift)\n\nLeft shift of all pixels of the image." },
    {"SubImage", (PyCFunction)PyHirschImageArray_SubImage, METH_VARARGS, "SubImage(ImageSubtrahend,Mult,Add)\n\nSubtract two images." },
    {"GenProjectiveMosaic", (PyCFunction)PyHirschImageArray_GenProjectiveMosaic, METH_VARARGS, "GenProjectiveMosaic(StartImage,MappingSource,MappingDest,HomMatrices2D,StackingOrder,TransformRegion)\n\nCombine multiple images into a mosaic image." },
    {"ScaleImage", (PyCFunction)PyHirschImageArray_ScaleImage, METH_VARARGS, "ScaleImage(Mult,Add)\n\nScale the gray values of an image." },
    {"PolarTransImageExt", (PyCFunction)PyHirschImageArray_PolarTransImageExt, METH_VARARGS, "PolarTransImageExt(Row,Column,AngleStart,AngleEnd,RadiusStart,RadiusEnd,Width,Height,Interpolation)\n\nTransform an annular arc in an image to polar coordinates." },
    {"SmoothImage", (PyCFunction)PyHirschImageArray_SmoothImage, METH_VARARGS, "SmoothImage(Filter,Alpha)\n\nSmooth an image using recursive filters." },
    {"FreiAmp", (PyCFunction)PyHirschImageArray_FreiAmp, METH_NOARGS, "FreiAmp()\n\nDetect edges (amplitude) using the Frei-Chen operator." },
    {"EstimateTiltZc", (PyCFunction)PyHirschImageArray_EstimateTiltZc, METH_NOARGS, "EstimateTiltZc()\n\nEstimate the tilt of a light source." },
    {"DispChannel", (PyCFunction)PyHirschImageArray_DispChannel, METH_VARARGS, "DispChannel(WindowHandle,Channel)\n\nDisplays images with several channels." },
    {"MultImage", (PyCFunction)PyHirschImageArray_MultImage, METH_VARARGS, "MultImage(Image2,Mult,Add)\n\nMultiply two images." },
    {"SfsPentland", (PyCFunction)PyHirschImageArray_SfsPentland, METH_VARARGS, "SfsPentland(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"IsotropicDiffusion", (PyCFunction)PyHirschImageArray_IsotropicDiffusion, METH_VARARGS, "IsotropicDiffusion(Sigma,Iterations)\n\nPerform an isotropic diffusion of an image." },
    {"Lowlands", (PyCFunction)PyHirschImageArray_Lowlands, METH_NOARGS, "Lowlands()\n\nDetect all gray value lowlands." },
    {"GetDomain", (PyCFunction)PyHirschImageArray_GetDomain, METH_NOARGS, "GetDomain()\n\nGet the domain of an image." },
    {"GrayOpeningRect", (PyCFunction)PyHirschImageArray_GrayOpeningRect, METH_VARARGS, "GrayOpeningRect(MaskHeight,MaskWidth)\n\nPerform a gray value opening with a rectangular mask." },
    {"RealToVectorField", (PyCFunction)PyHirschImageArray_RealToVectorField, METH_VARARGS, "RealToVectorField(Col)\n\nConvert two real-valued images into a vector field image." },
    {"PowerLn", (PyCFunction)PyHirschImageArray_PowerLn, METH_NOARGS, "PowerLn()\n\nReturn the power spectrum of a complex image." },
    {"DualThreshold", (PyCFunction)PyHirschImageArray_DualThreshold, METH_VARARGS, "DualThreshold(MinSize,MinGray,Threshold)\n\nThreshold operator for signed images." },
    {"Rectangle1Domain", (PyCFunction)PyHirschImageArray_Rectangle1Domain, METH_VARARGS, "Rectangle1Domain(Row1,Column1,Row2,Column2)\n\nReduce the domain of an image to a rectangle." },
    {"ExpandDomainGray", (PyCFunction)PyHirschImageArray_ExpandDomainGray, METH_VARARGS, "ExpandDomainGray(ExpansionRange)\n\nExpand the domain of an image and set the gray values in the\nexpanded domain." },
    {"TileImagesOffset", (PyCFunction)PyHirschImageArray_TileImagesOffset, METH_VARARGS, "TileImagesOffset(OffsetRow,OffsetCol,Row1,Col1,Row2,Col2,Width,Height)\n\nTile multiple image objects into a large image with explicit\npositioning information." },
    {"EquHistoImage", (PyCFunction)PyHirschImageArray_EquHistoImage, METH_NOARGS, "EquHistoImage()\n\nHistogram linearisation of images" },
    {"FastThreshold", (PyCFunction)PyHirschImageArray_FastThreshold, METH_VARARGS, "FastThreshold(MinGray,MaxGray,MinSize)\n\nFast thresholding of images using global thresholds." },
    {"EstimateAlAm", (PyCFunction)PyHirschImageArray_EstimateAlAm, METH_NOARGS, "EstimateAlAm()\n\nEstimate the albedo of a surface and the amount of ambient light." },
    {"ReadOcrTrainfSelect", (PyCFunction)PyHirschImageArray_ReadOcrTrainfSelect, METH_STATIC|METH_VARARGS, "ReadOcrTrainfSelect(TrainFileNames,SearchNames)\n\nRead training specific characters from files and convert to images." },
    {"RobinsonAmp", (PyCFunction)PyHirschImageArray_RobinsonAmp, METH_NOARGS, "RobinsonAmp()\n\nDetect edges (amplitude) using the Robinson operator." },
    {"LocalMin", (PyCFunction)PyHirschImageArray_LocalMin, METH_NOARGS, "LocalMin()\n\nDetect all local minima in an image." },
    {"ShadeHeightField", (PyCFunction)PyHirschImageArray_ShadeHeightField, METH_VARARGS, "ShadeHeightField(Slant,Tilt,Albedo,Ambient,Shadows)\n\nShade a height field." },
    {"MidrangeImage", (PyCFunction)PyHirschImageArray_MidrangeImage, METH_VARARGS, "MidrangeImage(Mask,Margin)\n\nCalculate the average of maximum and minimum inside any mask." },
    {"Rgb1ToGray", (PyCFunction)PyHirschImageArray_Rgb1ToGray, METH_NOARGS, "Rgb1ToGray()\n\nTransform an RGB image into a gray scale image." },
    {"BitOr", (PyCFunction)PyHirschImageArray_BitOr, METH_VARARGS, "BitOr(Image2)\n\nBit-by-bit OR of all pixels of the input images." },
    {"CropDomainRel", (PyCFunction)PyHirschImageArray_CropDomainRel, METH_VARARGS, "CropDomainRel(Top,Left,Bottom,Right)\n\nCut out an image area relative to the domain." },
    {"CropPart", (PyCFunction)PyHirschImageArray_CropPart, METH_VARARGS, "CropPart(Row,Column,Width,Height)\n\nCut out a rectangular image area." },
    {"SqrtImage", (PyCFunction)PyHirschImageArray_SqrtImage, METH_NOARGS, "SqrtImage()\n\nCalculate the square root of an image." },
    {"TextureLaws", (PyCFunction)PyHirschImageArray_TextureLaws, METH_VARARGS, "TextureLaws(FilterTypes,Shift,FilterSize)\n\nFilter an image using a Laws texture filter." },
    {"GenBinocularProjRectification", (PyCFunction)PyHirschImageArray_GenBinocularProjRectification, METH_STATIC|METH_VARARGS, "GenBinocularProjRectification(FMatrix,CovFMat,Width1,Height1,Width2,Height2,SubSampling,Mapping)\n\nCompute the projective rectification of weakly calibrated binocular\nstereo images." },
    {"OpticalFlowMg", (PyCFunction)PyHirschImageArray_OpticalFlowMg, METH_VARARGS, "OpticalFlowMg(Image2,Algorithm,SmoothingSigma,IntegrationSigma,FlowSmoothness,GradientConstancy,MGParamName,MGParamValue)\n\nCompute the optical flow between two images." },
    {"EstimateTiltLr", (PyCFunction)PyHirschImageArray_EstimateTiltLr, METH_NOARGS, "EstimateTiltLr()\n\nEstimate the tilt of a light source." },
    {"RotateImage", (PyCFunction)PyHirschImageArray_RotateImage, METH_VARARGS, "RotateImage(Phi,Interpolation)\n\nRotate an image about its center." },
    {"PowerByte", (PyCFunction)PyHirschImageArray_PowerByte, METH_NOARGS, "PowerByte()\n\nReturn the power spectrum of a complex image." },
    {"GrayRangeRect", (PyCFunction)PyHirschImageArray_GrayRangeRect, METH_VARARGS, "GrayRangeRect(MaskHeight,MaskWidth)\n\nDetermine the gray value range within a rectangle." },
    {"Illuminate", (PyCFunction)PyHirschImageArray_Illuminate, METH_VARARGS, "Illuminate(MaskWidth,MaskHeight,Factor)\n\nIlluminate image." },
    {"CountChannels", (PyCFunction)PyHirschImageArray_CountChannels, METH_NOARGS, "CountChannels()\n\nCount channels of image." },
    {"BinocularDisparityMg", (PyCFunction)PyHirschImageArray_BinocularDisparityMg, METH_VARARGS, "BinocularDisparityMg(Image2,GrayConstancy,GradientConstancy,Smoothness,InitialGuess,CalculateScore,MGParamName,MGParamValue)\n\nCompute the disparities of a rectified image pair using multigrid\nmethods." },
    {"AdaptTemplate", (PyCFunction)PyHirschImageArray_AdaptTemplate, METH_VARARGS, "AdaptTemplate(TemplateID)\n\nAdapting a template to the size of an image." },
    {"CorrelationFft", (PyCFunction)PyHirschImageArray_CorrelationFft, METH_VARARGS, "CorrelationFft(ImageFFT2)\n\nCompute the correlation of two images in the frequency domain." },
    {"Symmetry", (PyCFunction)PyHirschImageArray_Symmetry, METH_VARARGS, "Symmetry(MaskSize,Direction,Exponent)\n\nSymmetry of gray values along a row." },
    {"HysteresisThreshold", (PyCFunction)PyHirschImageArray_HysteresisThreshold, METH_VARARGS, "HysteresisThreshold(Low,High,MaxLength)\n\nPerform a hysteresis threshold operation on an image." },
    {"VarThreshold", (PyCFunction)PyHirschImageArray_VarThreshold, METH_VARARGS, "VarThreshold(MaskWidth,MaskHeight,StdDevScale,AbsThreshold,LightDark)\n\nThreshold an image by local mean and standard deviation analysis." },
    {"DivImage", (PyCFunction)PyHirschImageArray_DivImage, METH_VARARGS, "DivImage(Image2,Mult,Add)\n\nDivide two images." },
    {"Plateaus", (PyCFunction)PyHirschImageArray_Plateaus, METH_NOARGS, "Plateaus()\n\nDetect all gray value plateaus." },
    {"FftImageInv", (PyCFunction)PyHirschImageArray_FftImageInv, METH_NOARGS, "FftImageInv()\n\nCompute the inverse fast Fourier transform of an image." },
    {"FindScaledShapeModels", (PyCFunction)PyHirschImageArray_FindScaledShapeModels, METH_VARARGS, "FindScaledShapeModels(ModelIDs,AngleStart,AngleExtent,ScaleMin,ScaleMax,MinScore,NumMatches,MaxOverlap,SubPixel,NumLevels,Greediness)\n\nFind the best matches of multiple scale invariant shape models." },
    {"LabelToRegion", (PyCFunction)PyHirschImageArray_LabelToRegion, METH_NOARGS, "LabelToRegion()\n\nExtract regions with equal gray values from an image." },
    {"ReduceDomain", (PyCFunction)PyHirschImageArray_ReduceDomain, METH_VARARGS, "ReduceDomain(Region)\n\nReduce the domain of an image." },
    {"PhaseDeg", (PyCFunction)PyHirschImageArray_PhaseDeg, METH_NOARGS, "PhaseDeg()\n\nReturn the phase of a complex image in degrees." },
    {"CropDomain", (PyCFunction)PyHirschImageArray_CropDomain, METH_NOARGS, "CropDomain()\n\nCut out of defined gray values." },
    {"BestMatchPreMg", (PyCFunction)PyHirschImageArray_BestMatchPreMg, METH_VARARGS, "BestMatchPreMg(TemplateID,MaxError,SubPixel,NumLevels,WhichLevels)\n\nSearching the best grayvalue matches in a pre generated pyramid." },
    {"ChangeRadialDistortionImage", (PyCFunction)PyHirschImageArray_ChangeRadialDistortionImage, METH_VARARGS, "ChangeRadialDistortionImage(Region,CamParamIn,CamParamOut)\n\nChange the radial distortion of an image." },
    {"GrayClosing", (PyCFunction)PyHirschImageArray_GrayClosing, METH_VARARGS, "GrayClosing(SE)\n\nPerform a gray value closing on an image." },
    {"DerivateGauss", (PyCFunction)PyHirschImageArray_DerivateGauss, METH_VARARGS, "DerivateGauss(Sigma,Component)\n\nConvolve an image with derivatives of the Gaussian." },
    {"CropRectangle1", (PyCFunction)PyHirschImageArray_CropRectangle1, METH_VARARGS, "CropRectangle1(Row1,Column1,Row2,Column2)\n\nCut out a rectangular image area." },
    {"ConvolGabor", (PyCFunction)PyHirschImageArray_ConvolGabor, METH_VARARGS, "ConvolGabor(GaborFilter)\n\nConvolve an image with a Gabor filter in the frequency domain." },
    {"GrayDilationShape", (PyCFunction)PyHirschImageArray_GrayDilationShape, METH_VARARGS, "GrayDilationShape(MaskHeight,MaskWidth,MaskShape)\n\nDetermine the maximum gray value within a selected mask." },
    {"MeanSp", (PyCFunction)PyHirschImageArray_MeanSp, METH_VARARGS, "MeanSp(MaskWidth,MaskHeight,MinThresh,MaxThresh)\n\nSuppress salt and pepper noise." },
    {"WriteOcrTrainfImage", (PyCFunction)PyHirschImageArray_WriteOcrTrainfImage, METH_VARARGS, "WriteOcrTrainfImage(Class,FileName)\n\nWrite characters into a training file." },
    {"PowerReal", (PyCFunction)PyHirschImageArray_PowerReal, METH_NOARGS, "PowerReal()\n\nReturn the power spectrum of a complex image." },
    {"GrayTophat", (PyCFunction)PyHirschImageArray_GrayTophat, METH_VARARGS, "GrayTophat(SE)\n\nPerform a gray value top hat transformation on an image." },
    {"GaussImage", (PyCFunction)PyHirschImageArray_GaussImage, METH_VARARGS, "GaussImage(Size)\n\nSmooth using discrete Gauss functions." },
    {"Append", (PyCFunction)PyHirschImageArray_Append, METH_VARARGS, "Append(image)\n\n" },
    {"DynThreshold", (PyCFunction)PyHirschImageArray_DynThreshold, METH_VARARGS, "DynThreshold(ThresholdImage,Offset,LightDark)\n\nSegment an image using a local threshold." },
    {"NonmaxSuppressionDir", (PyCFunction)PyHirschImageArray_NonmaxSuppressionDir, METH_VARARGS, "NonmaxSuppressionDir(ImgDir,Mode)\n\nSuppress non-maximum points on an edge using a direction image." },
    {"MaxImage", (PyCFunction)PyHirschImageArray_MaxImage, METH_VARARGS, "MaxImage(Image2)\n\nCalculate the maximum of two images pixel by pixel." },
    {"FftImage", (PyCFunction)PyHirschImageArray_FftImage, METH_NOARGS, "FftImage()\n\nCompute the fast Fourier transform of an image." },
    {"ConvolFft", (PyCFunction)PyHirschImageArray_ConvolFft, METH_VARARGS, "ConvolFft(ImageFilter)\n\nConvolve an image with a filter in the frequency domain." },
    {"GrayErosion", (PyCFunction)PyHirschImageArray_GrayErosion, METH_VARARGS, "GrayErosion(SE)\n\nPerform a gray value erosion on an image." },
    {"RadiometricSelfCalibration", (PyCFunction)PyHirschImageArray_RadiometricSelfCalibration, METH_VARARGS, "RadiometricSelfCalibration(ExposureRatios,Features,FunctionType,Smoothness,PolynomialDegree)\n\nPerform a radiometric self-calibration of a camera." },
    {"FindAnisoShapeModels", (PyCFunction)PyHirschImageArray_FindAnisoShapeModels, METH_VARARGS, "FindAnisoShapeModels(ModelIDs,AngleStart,AngleExtent,ScaleRMin,ScaleRMax,ScaleCMin,ScaleCMax,MinScore,NumMatches,MaxOverlap,SubPixel,NumLevels,Greediness)\n\nFind the best matches of multiple anisotropic scale invariant shape\nmodels." },
    {"ConvolImage", (PyCFunction)PyHirschImageArray_ConvolImage, METH_VARARGS, "ConvolImage(FilterMask,Margin)\n\nConvolve an image with an arbitrary filter mask." },
    {"ShockFilter", (PyCFunction)PyHirschImageArray_ShockFilter, METH_VARARGS, "ShockFilter(Theta,Iterations,Mode,Sigma)\n\nApply a shock filter to an image." },
    {"DotsImage", (PyCFunction)PyHirschImageArray_DotsImage, METH_VARARGS, "DotsImage(Diameter,FilterType,PixelShift)\n\nEnhance circular dots in an image." },
    {"RobinsonDir", (PyCFunction)PyHirschImageArray_RobinsonDir, METH_NOARGS, "RobinsonDir()\n\nDetect edges (amplitude and direction) using the Robinson operator." },
    {"EntropyImage", (PyCFunction)PyHirschImageArray_EntropyImage, METH_VARARGS, "EntropyImage(Width,Height)\n\nCalculate the entropy of gray values within a rectangular window." },
    {"ZoomImageFactor", (PyCFunction)PyHirschImageArray_ZoomImageFactor, METH_VARARGS, "ZoomImageFactor(ScaleWidth,ScaleHeight,Interpolation)\n\nZoom an image by a given factor." },
    {"Class2dimSup", (PyCFunction)PyHirschImageArray_Class2dimSup, METH_VARARGS, "Class2dimSup(ImageRow,FeatureSpace)\n\nSegment an image using two-dimensional pixel classification." },
    {"FullDomain", (PyCFunction)PyHirschImageArray_FullDomain, METH_NOARGS, "FullDomain()\n\nExpand the domain of an image to maximum." },
    {"MedianWeighted", (PyCFunction)PyHirschImageArray_MedianWeighted, METH_VARARGS, "MedianWeighted(MaskType,MaskSize)\n\nWeighted median filtering with different rank masks." },
    {"PhaseRad", (PyCFunction)PyHirschImageArray_PhaseRad, METH_NOARGS, "PhaseRad()\n\nReturn the phase of a complex image in radians." },
    {"WriteImage", (PyCFunction)PyHirschImageArray_WriteImage, METH_VARARGS, "WriteImage(Format,FillColor,FileName)\n\nWrite images in graphic formats." },
    {"CopyHImageArray", (PyCFunction)PyHirschImageArray_CopyHImageArray, METH_VARARGS, "CopyHImageArray(in)\n\n" },
    {"FastMatchMg", (PyCFunction)PyHirschImageArray_FastMatchMg, METH_VARARGS, "FastMatchMg(TemplateID,MaxError,NumLevel)\n\nSearching all good grayvalue matches in a pyramid." },
    {"DeviationImage", (PyCFunction)PyHirschImageArray_DeviationImage, METH_VARARGS, "DeviationImage(Width,Height)\n\nCalculate the standard deviation of gray values within rectangular windows." },
    {"EstimateNoise", (PyCFunction)PyHirschImageArray_EstimateNoise, METH_VARARGS, "EstimateNoise(Method,Percent)\n\nEstimate the image noise from a single image." },
    {"AddImage", (PyCFunction)PyHirschImageArray_AddImage, METH_VARARGS, "AddImage(Image2,Mult,Add)\n\nAdd two images." },
    {"Monotony", (PyCFunction)PyHirschImageArray_Monotony, METH_NOARGS, "Monotony()\n\nCalculating the monotony operation." },
    {"ZeroCrossing", (PyCFunction)PyHirschImageArray_ZeroCrossing, METH_NOARGS, "ZeroCrossing()\n\nExtrakt zero crossings from an image." },
    {"NonmaxSuppressionAmp", (PyCFunction)PyHirschImageArray_NonmaxSuppressionAmp, METH_VARARGS, "NonmaxSuppressionAmp(Mode)\n\nSuppress non-maximum points on an edge." },
    {"RegiongrowingMean", (PyCFunction)PyHirschImageArray_RegiongrowingMean, METH_VARARGS, "RegiongrowingMean(StartRows,StartColumns,Tolerance,MinSize)\n\nPerform a regiongrowing using mean gray values." },
    {"GrayClosingRect", (PyCFunction)PyHirschImageArray_GrayClosingRect, METH_VARARGS, "GrayClosingRect(MaskHeight,MaskWidth)\n\nPerform a gray value closing with a rectangular mask." },
    {"AffineTransImageSize", (PyCFunction)PyHirschImageArray_AffineTransImageSize, METH_VARARGS, "AffineTransImageSize(HomMat2D,Interpolation,Width,Height)\n\nApply an arbitrary affine 2D transformation to an image and specify\nthe output image size." },
    {"GenInitialComponents", (PyCFunction)PyHirschImageArray_GenInitialComponents, METH_VARARGS, "GenInitialComponents(ContrastLow,ContrastHigh,MinSize,Mode,GenericName,GenericValue)\n\nExtract the initial components of a component model." },
    {"MeanImage", (PyCFunction)PyHirschImageArray_MeanImage, METH_VARARGS, "MeanImage(MaskWidth,MaskHeight)\n\nSmooth by averaging." },
    {"TileImages", (PyCFunction)PyHirschImageArray_TileImages, METH_VARARGS, "TileImages(NumColumns,TileOrder)\n\nTile multiple image objects into a large image." },
    {"SfsOrigLr", (PyCFunction)PyHirschImageArray_SfsOrigLr, METH_VARARGS, "SfsOrigLr(Slant,Tilt,Albedo,Ambient)\n\nReconstruct a surface from a gray value image." },
    {"GenPrincipalCompTrans", (PyCFunction)PyHirschImageArray_GenPrincipalCompTrans, METH_NOARGS, "GenPrincipalCompTrans()\n\nCompute the transformation matrix of the principal component\nanalysis of multichannel images." },
    {"GrayBothat", (PyCFunction)PyHirschImageArray_GrayBothat, METH_VARARGS, "GrayBothat(SE)\n\nPerform a gray value bottom hat transformation on an image." },
    {"ProjectiveTransImage", (PyCFunction)PyHirschImageArray_ProjectiveTransImage, METH_VARARGS, "ProjectiveTransImage(HomMat2D,Interpolation,AdaptImageSize,TransformRegion)\n\nApply a projective transformation to an image." },
    {"FreiDir", (PyCFunction)PyHirschImageArray_FreiDir, METH_NOARGS, "FreiDir()\n\nDetect edges (amplitude and direction) using the Frei-Chen operator." },
    {"Rgb3ToGray", (PyCFunction)PyHirschImageArray_Rgb3ToGray, METH_VARARGS, "Rgb3ToGray(ImageGreen,ImageBlue)\n\nTransform an RGB image to a gray scale image." },
    {"GrayDilationRect", (PyCFunction)PyHirschImageArray_GrayDilationRect, METH_VARARGS, "GrayDilationRect(MaskHeight,MaskWidth)\n\nDetermine the maximum gray value within a rectangle." },
    {"EnergyGabor", (PyCFunction)PyHirschImageArray_EnergyGabor, METH_VARARGS, "EnergyGabor(ImageHilbert)\n\nCalculate the energy of a two-channel image." },
    {"Laplace", (PyCFunction)PyHirschImageArray_Laplace, METH_VARARGS, "Laplace(ResultType,MaskSize,FilterMask)\n\nCalculate the Laplace operator by using finite differences." },
    {"EstimateSlAlZc", (PyCFunction)PyHirschImageArray_EstimateSlAlZc, METH_NOARGS, "EstimateSlAlZc()\n\nEstimate the slant of a light source and the albedo of a surface." },
    {"AffineTransImage", (PyCFunction)PyHirschImageArray_AffineTransImage, METH_VARARGS, "AffineTransImage(HomMat2D,Interpolation,AdaptImageSize)\n\nApply an arbitrary affine 2D transformation to images." },
    {"RftGeneric", (PyCFunction)PyHirschImageArray_RftGeneric, METH_VARARGS, "RftGeneric(Direction,Norm,ResultType,Width)\n\nCompute the real-valued fast Fourier transform of an image." },
    {"GrayClosingShape", (PyCFunction)PyHirschImageArray_GrayClosingShape, METH_VARARGS, "GrayClosingShape(MaskHeight,MaskWidth,MaskShape)\n\nPerform a grayvalue closing with a selected mask." },
    {"MedianImage", (PyCFunction)PyHirschImageArray_MedianImage, METH_VARARGS, "MedianImage(MaskType,Radius,Margin)\n\nMedian filtering with different rank masks." },
    {"HClassName", (PyCFunction)PyHirschImageArray_HClassName, METH_NOARGS, "HClassName()\n\nTools" },
    {"GrayOpening", (PyCFunction)PyHirschImageArray_GrayOpening, METH_VARARGS, "GrayOpening(SE)\n\nPerform a gray value opening on an image." },
    {"AnisotropeDiff", (PyCFunction)PyHirschImageArray_AnisotropeDiff, METH_VARARGS, "AnisotropeDiff(Percent,Mode,Iteration,NeighborhoodType)\n\nSmooth an image by edge-preserving anisotropic diffusion." },
    {"InpaintingMcf", (PyCFunction)PyHirschImageArray_InpaintingMcf, METH_VARARGS, "InpaintingMcf(Region,Sigma,Theta,Iterations)\n\nPerform an inpainting by smoothing of level lines." },
    {"BitMask", (PyCFunction)PyHirschImageArray_BitMask, METH_VARARGS, "BitMask(BitMask)\n\nLogical \"AND\" of each pixel using a bit mask." },
    {"BinocularDistanceMg", (PyCFunction)PyHirschImageArray_BinocularDistanceMg, METH_VARARGS, "BinocularDistanceMg(Image2,CamParamRect1,CamParamRect2,RelPoseRect,GrayConstancy,GradientConstancy,Smoothness,InitialGuess,CalculateScore,MGParamName,MGParamValue)\n\nCompute the distance values for a rectified stereo image pair using \nmultigrid methods." },
    {"ZoomImageSize", (PyCFunction)PyHirschImageArray_ZoomImageSize, METH_VARARGS, "ZoomImageSize(Width,Height,Interpolation)\n\nZoom an image to a given size." },
    {"CharThreshold", (PyCFunction)PyHirschImageArray_CharThreshold, METH_VARARGS, "CharThreshold(HistoRegion,Sigma,Percent)\n\nPerform a threshold segmentation for extracting characters." },
    {"BestMatch", (PyCFunction)PyHirschImageArray_BestMatch, METH_VARARGS, "BestMatch(TemplateID,MaxError,SubPixel)\n\nSearching the best matching of a template and an image." },
    {"MeanCurvatureFlow", (PyCFunction)PyHirschImageArray_MeanCurvatureFlow, METH_VARARGS, "MeanCurvatureFlow(Sigma,Theta,Iterations)\n\nApply the mean curvature flow to an image." },
    {"ReadOcrTrainf", (PyCFunction)PyHirschImageArray_ReadOcrTrainf, METH_STATIC|METH_VARARGS, "ReadOcrTrainf(TrainFileNames)\n\nRead training characters from files and convert to images." },
    {"AddNoiseWhite", (PyCFunction)PyHirschImageArray_AddNoiseWhite, METH_VARARGS, "AddNoiseWhite(Amp)\n\nAdd noise to an image." },
    {"LinearTransColor", (PyCFunction)PyHirschImageArray_LinearTransColor, METH_VARARGS, "LinearTransColor(TransMat)\n\nCompute an affine transformation of the color values of a\nmultichannel image." },
    {"PrewittDir", (PyCFunction)PyHirschImageArray_PrewittDir, METH_NOARGS, "PrewittDir()\n\nDetect edges (amplitude and direction) using the Prewitt operator." },
    {"VectorFieldToReal", (PyCFunction)PyHirschImageArray_VectorFieldToReal, METH_NOARGS, "VectorFieldToReal()\n\nConvert a vector field image into two real-valued images." },
    {"InpaintingCed", (PyCFunction)PyHirschImageArray_InpaintingCed, METH_VARARGS, "InpaintingCed(Region,Sigma,Rho,Theta,Iterations)\n\nPerform an inpainting by coherence enhancing diffusion." },
    {"ScaleImageMax", (PyCFunction)PyHirschImageArray_ScaleImageMax, METH_NOARGS, "ScaleImageMax()\n\nMaximum gray value spreading in the value range \n0 to 255." },
    {"BitSlice", (PyCFunction)PyHirschImageArray_BitSlice, METH_VARARGS, "BitSlice(Bit)\n\nExtract a bit from the pixels." },
    {"BitRshift", (PyCFunction)PyHirschImageArray_BitRshift, METH_VARARGS, "BitRshift(Shift)\n\nRight shift of all pixels of the image." },
    {"UnwarpImageVectorField", (PyCFunction)PyHirschImageArray_UnwarpImageVectorField, METH_VARARGS, "UnwarpImageVectorField(VectorField)\n\nUnwarp an image using a vector field." },
    {"ExpandLine", (PyCFunction)PyHirschImageArray_ExpandLine, METH_VARARGS, "ExpandLine(Coordinate,ExpandType,RowColumn,Threshold)\n\nExpand a region starting at a given line." },
    {"ChannelsToImage", (PyCFunction)PyHirschImageArray_ChannelsToImage, METH_NOARGS, "ChannelsToImage()\n\nConvert one-channel images into a multichannel image" },
    {"FindShapeModels", (PyCFunction)PyHirschImageArray_FindShapeModels, METH_VARARGS, "FindShapeModels(ModelIDs,AngleStart,AngleExtent,MinScore,NumMatches,MaxOverlap,SubPixel,NumLevels,Greediness)\n\nFind the best matches of multiple shape models." },
    {"LutTrans", (PyCFunction)PyHirschImageArray_LutTrans, METH_VARARGS, "LutTrans(Lut)\n\nTransform an image with a gray-value look-up-table" },
    {"AnisotropicDiffusion", (PyCFunction)PyHirschImageArray_AnisotropicDiffusion, METH_VARARGS, "AnisotropicDiffusion(Mode,Contrast,Theta,Iterations)\n\nPerform an anisotropic diffusion of an image." },
    {"TransFromRgb", (PyCFunction)PyHirschImageArray_TransFromRgb, METH_VARARGS, "TransFromRgb(ImageGreen,ImageBlue,ColorSpace)\n\nTransform an image from the RGB color space to an arbitrary color space." },
    {"DualRank", (PyCFunction)PyHirschImageArray_DualRank, METH_VARARGS, "DualRank(MaskType,Radius,ModePercent,Margin)\n\nOpening, Median and Closing with circle or rectangle mask." },
    {"PolarTransImage", (PyCFunction)PyHirschImageArray_PolarTransImage, METH_VARARGS, "PolarTransImage(Row,Column,Width,Height)\n\nTransform an image to polar coordinates" },
    {"InpaintingAniso", (PyCFunction)PyHirschImageArray_InpaintingAniso, METH_VARARGS, "InpaintingAniso(Region,Mode,Contrast,Theta,Iterations,Rho)\n\nPerform an inpainting by anisotropic diffusion." },
    {"SobelDir", (PyCFunction)PyHirschImageArray_SobelDir, METH_VARARGS, "SobelDir(FilterType,Size)\n\nDetect edges (amplitude and direction) using the Sobel operator." },
    {"ReadImage", (PyCFunction)PyHirschImageArray_ReadImage, METH_STATIC|METH_VARARGS, "ReadImage(FileName)\n\nRead an image with different file formats." },
    {"Regiongrowing", (PyCFunction)PyHirschImageArray_Regiongrowing, METH_VARARGS, "Regiongrowing(Row,Column,Tolerance,MinSize)\n\nSegment an image using regiongrowing." },
    {"LaplaceOfGauss", (PyCFunction)PyHirschImageArray_LaplaceOfGauss, METH_VARARGS, "LaplaceOfGauss(Sigma)\n\nLoG-Operator (Laplace of Gaussian)." },
    {"MedianSeparate", (PyCFunction)PyHirschImageArray_MedianSeparate, METH_VARARGS, "MedianSeparate(MaskWidth,MaskHeight,Margin)\n\nSeparated median filtering with rectangle masks." },
    {"Threshold", (PyCFunction)PyHirschImageArray_Threshold, METH_VARARGS, "Threshold(MinGray,MaxGray)\n\nSegment an image using global threshold." },
    {"EstimateSlAlLr", (PyCFunction)PyHirschImageArray_EstimateSlAlLr, METH_NOARGS, "EstimateSlAlLr()\n\nEstimate the slant of a light source and the albedo of a surface." },
    {"KirschDir", (PyCFunction)PyHirschImageArray_KirschDir, METH_NOARGS, "KirschDir()\n\nDetect edges (amplitude and direction) using the Kirsch operator." },
    {"BitNot", (PyCFunction)PyHirschImageArray_BitNot, METH_NOARGS, "BitNot()\n\nComplement all bits of the pixels." },
    {"EdgesImage", (PyCFunction)PyHirschImageArray_EdgesImage, METH_VARARGS, "EdgesImage(Filter,Alpha,NMS,Low,High)\n\nExtract edges using Deriche, Lanser, Shen, or Canny filters." },
    {"AbsDiffImage", (PyCFunction)PyHirschImageArray_AbsDiffImage, METH_VARARGS, "AbsDiffImage(Image2,Mult)\n\nCalculate the absolute difference of two images." },
    {"RankImage", (PyCFunction)PyHirschImageArray_RankImage, METH_VARARGS, "RankImage(Mask,Rank,Margin)\n\nSmooth an image with an arbitrary rank mask." },
    {"FftGeneric", (PyCFunction)PyHirschImageArray_FftGeneric, METH_VARARGS, "FftGeneric(Direction,Exponent,Norm,Mode,ResultType)\n\nCompute the fast Fourier transform of an image." },
    {"GrayDilation", (PyCFunction)PyHirschImageArray_GrayDilation, METH_VARARGS, "GrayDilation(SE)\n\nPerform a gray value dilation on an image." },
    {"RealToComplex", (PyCFunction)PyHirschImageArray_RealToComplex, METH_VARARGS, "RealToComplex(ImageImaginary)\n\nConvert two real images into a complex image." },
    {"InpaintingCt", (PyCFunction)PyHirschImageArray_InpaintingCt, METH_VARARGS, "InpaintingCt(Region,Epsilon,Kappa,Sigma,Rho,ChannelCoefficients)\n\nPerform an inpainting by coherence transport." },
    {"GrayOpeningShape", (PyCFunction)PyHirschImageArray_GrayOpeningShape, METH_VARARGS, "GrayOpeningShape(MaskHeight,MaskWidth,MaskShape)\n\nPerform a gray value opening with a selected mask." },
    {"BitXor", (PyCFunction)PyHirschImageArray_BitXor, METH_VARARGS, "BitXor(Image2)\n\nBit-by-bit XOR of all pixels of the input images." },
    {"AutoThreshold", (PyCFunction)PyHirschImageArray_AutoThreshold, METH_VARARGS, "AutoThreshold(Sigma)\n\nSegment an image using thresholds determined from its histogram." },
    {"SigmaImage", (PyCFunction)PyHirschImageArray_SigmaImage, METH_VARARGS, "SigmaImage(MaskHeight,MaskWidth,Sigma)\n\nNon-linear smoothing with the sigma filter." },
    {"CoherenceEnhancingDiff", (PyCFunction)PyHirschImageArray_CoherenceEnhancingDiff, METH_VARARGS, "CoherenceEnhancingDiff(Sigma,Rho,Theta,Iterations)\n\nPerform a coherence enhancing diffusion of an image." },
    {"GrayInside", (PyCFunction)PyHirschImageArray_GrayInside, METH_NOARGS, "GrayInside()\n\nCalculate the lowest possible gray value on an arbitrary path to the\nimage border for each point in the image." },
    {"RegiongrowingN", (PyCFunction)PyHirschImageArray_RegiongrowingN, METH_VARARGS, "RegiongrowingN(Metric,MinTolerance,MaxTolerance,MinSize)\n\nSegment an image using regiongrowing for multi-channel images." },
    {"BestMatchMg", (PyCFunction)PyHirschImageArray_BestMatchMg, METH_VARARGS, "BestMatchMg(TemplateID,MaxError,SubPixel,NumLevels,WhichLevels)\n\nSearching the best grayvalue matches in a pyramid." },
    {"Decompose4", (PyCFunction)PyHirschImageArray_Decompose4, METH_NOARGS, "Decompose4()\n\nConvert a four-channel image into four images." },
    {"FastMatch", (PyCFunction)PyHirschImageArray_FastMatch, METH_VARARGS, "FastMatch(TemplateID,MaxError)\n\nSearching all good matches of a template and an image." },
    {"CornerResponse", (PyCFunction)PyHirschImageArray_CornerResponse, METH_VARARGS, "CornerResponse(Size,Weight)\n\nSearching corners in images." },
    {"Watersheds", (PyCFunction)PyHirschImageArray_Watersheds, METH_NOARGS, "Watersheds()\n\nExtract watersheds and basins from an image." },
    {"ExhaustiveMatchMg", (PyCFunction)PyHirschImageArray_ExhaustiveMatchMg, METH_VARARGS, "ExhaustiveMatchMg(ImageTemplate,Mode,Level,Threshold)\n\nMatching a template and an image in a resolution pyramid." },
    {"ChangeDomain", (PyCFunction)PyHirschImageArray_ChangeDomain, METH_VARARGS, "ChangeDomain(NewDomain)\n\nChange definition domain of an image." },
    {"ProjectiveTransImageSize", (PyCFunction)PyHirschImageArray_ProjectiveTransImageSize, METH_VARARGS, "ProjectiveTransImageSize(HomMat2D,Interpolation,Width,Height,TransformRegion)\n\nApply a projective transformation to an image and specify the output\nimage size." },
    {"Emphasize", (PyCFunction)PyHirschImageArray_Emphasize, METH_VARARGS, "Emphasize(MaskWidth,MaskHeight,Factor)\n\nEnhance contrast of the image." },
    {"ImageToWorldPlane", (PyCFunction)PyHirschImageArray_ImageToWorldPlane, METH_VARARGS, "ImageToWorldPlane(CamParam,WorldPose,Width,Height,Scale,Interpolation)\n\nRectify an image by transforming it into the plane z=0 of a world coordinate system." },
    {"RankN", (PyCFunction)PyHirschImageArray_RankN, METH_VARARGS, "RankN(RankIndex)\n\nReturn gray values with given rank from multiple channels." },
    {"LocalMax", (PyCFunction)PyHirschImageArray_LocalMax, METH_NOARGS, "LocalMax()\n\nDetect all local maxima in an image." },
    {"Decompose7", (PyCFunction)PyHirschImageArray_Decompose7, METH_NOARGS, "Decompose7()\n\nConvert a seven-channel image into seven images." },
    {"Decompose6", (PyCFunction)PyHirschImageArray_Decompose6, METH_NOARGS, "Decompose6()\n\nConvert a six-channel image into six images." },
    {"Decompose5", (PyCFunction)PyHirschImageArray_Decompose5, METH_NOARGS, "Decompose5()\n\nConvert a five-channel image into five images." },
    {"DeleteArray", (PyCFunction)PyHirschImageArray_DeleteArray, METH_NOARGS, "DeleteArray()\n\n" },
    {"Decompose3", (PyCFunction)PyHirschImageArray_Decompose3, METH_NOARGS, "Decompose3()\n\nConvert a three-channel image into three images." },
    {"Decompose2", (PyCFunction)PyHirschImageArray_Decompose2, METH_NOARGS, "Decompose2()\n\nConvert a two-channel image into two images." },
    {"PrewittAmp", (PyCFunction)PyHirschImageArray_PrewittAmp, METH_NOARGS, "PrewittAmp()\n\nDetect edges (amplitude) using the Prewitt operator." },